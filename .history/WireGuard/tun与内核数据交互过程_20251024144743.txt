1. 本地数据发送到公网的过程：
本地应用 → 生成 IP 数据包（目标：对端内网 IP）
    ↓
内核网络栈 → 根据路由表，将包发送到 tun 虚拟网卡（因配置了 VPN 路由规则）
    ↓
tun 设备 → 内核通过 TUN 接口，将 IP 包“拷贝”到用户态的 WireGuard 程序
    ↓
WireGuard → 加密数据包，封装为 WireGuard 格式 + UDP 头部
    ↓
WireGuard → 将 UDP 包通过系统调用（如 sendto）交给内核
    ↓
内核网络栈 → 为 UDP 包添加外层公网 IP 头（源：本地公网 IP，目标：对端公网 IP）
    ↓
物理网卡 → 内核将最终数据包通过物理网卡（如 eth0）发送到公网


2. 从公网接收数据到本地的过程：
物理网卡 → 接收公网发来的 UDP 包（源：对端公网 IP，目标：本地公网 IP:51820）
    ↓
内核网络栈 → 解析 UDP 包，发现目标端口是 WireGuard 监听的端口，将包交给用户态的 WireGuard 程序
    ↓
WireGuard → 解密 UDP 包中的数据，还原出原始 IP 数据包（目标：本地内网 IP）
    ↓
WireGuard → 通过 TUN 接口，将原始 IP 包“写入”tun 虚拟网卡
    ↓
内核网络栈 → 把 tun 设备收到的包当作“从网卡进来的真实数据”，根据路由表转发给本地应用


核心结论：
tun 依赖内核 TUN 接口：没有内核提供的 TUN 驱动和接口（如 Linux 的 /dev/net/tun 设备文件），用户态程序无法直接与内核网络栈交换 IP 数据包，tun 虚拟网卡也就失去了存在的基础。
物理网卡是最终载体：tun 仅负责 “用户态与内核态的 IP 包传递”，所有数据的实际收发（跨越物理网络）仍需依赖物理网卡，由内核网络栈完成底层的链路层封装（如以太网帧）和硬件交互。
简单说，tun 是 “内核与用户态之间的 IP 管道”，而物理网卡是 “管道的出入口”，两者分工不同但协同完成数据转发。