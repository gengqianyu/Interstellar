传输层：定义了主机 应用程序 之间端到端的连通性。

传输层最为常见的两个协议分别是：

	传输控制协议 TCP(Transmission Control Protocol)。
	用户数据报协议 UDP (User Datagram Protocol)。

TCP，UDP 都属于控制协议，本身不产生数据，帮应用层 应用 提供数据封装。
通过封装 TCP，UDP 的封装方便数据的发送；还有对数据进行切片功能，数据切片是传输层专属的功能，一般不建议在网络层做。

MTU 最大传输单元 是 Ethernet 2层的一个概念，4层协议是不会根据 MTU 进行切片的，传输层基于 MSS 最大分片大小，来做数据分片。

UDP 用户数据报协议：只有8 Byte

UDP 的报头格式：
				0				15				31
				|---------------|----------------|
				|source prot	|destination prot|
				|---------------|----------------|
				|UDP length 	|UDP Checksum	 |
				|---------------|----------------|

				Checksum 校验和的作用：丢包可以要求应用程序重新传送

TCP 传输控制协议：报头封装特别大 20-60 Byte

TCP 报头格式：
			0								15								31
		|---|-------------------------------|-------------------------------|
		|	|Source Prot					|Destination Prot				|	连接
		|	|-------------------------------|-------------------------------|
		|	|Sequence Number												|	可靠
		20	|---------------------------------------------------------------|
		Byte|Acknowledge Number												|
		|	|--------|----------|-|-|-|-|-|-|-------------------------------|
		|	|		 |			|U|A|P|R|S|F|								|
		|	|Header  |Resv		|R|C|S|S|Y|I|Window Size					|
		|	|Length	 |			|G|K|H|T|N|N|								|
		|	|--------|----------|-|-|-|-|-|-|-------------------------------|
		|	|TCP Checksum 					|Urgent Pointer					|
		|---|-------------------------------|-------------------------------|
			|Options														|
			|---------------------------------------------------------------|

面向*连接的可靠的* 传输层协议：

	突出一个可靠传输，用面向连接协议封装应用数据，能够保证应用程序在发送的时候是可靠的，只有 TCP 协议是一个面向连接协议。

	TCP 是一种面向连接的传输层协议，可提供可靠的传输服务。在传输数据之前，两台主机必须先建立一条可靠的传输通道。

TCP到底是怎样提供可靠传输功能的？

	保证传输不会出现拥塞，流控能力，
	因为,主机和主机之间发送数据不能保证带宽，主机性能都是一样。所以，通信前必须协商数据段大小。
	通过 Window(窗口)来协商传输数据的传输速率的协商。

	两台主机使用基于 TCP 的应用来传输数据，不是说传就传的，
	必须现在主机之间建立一个点到点的连接，连接需要交互三次连接的报文，因此我们也可以把这个连接称为 TCP 的 3 次握手连接，
	谁想要发送数据，就由谁发送第一个报文交互，
	应用的发送方发送一个 TCP SYN 同步报文，接收方收到以后回一个 SYN + ACK 的同步+确认的报文；
	发送方收到 SYN + ACK 之后，会给发送方再发一个 ACK 确认报文。

	这样就两台主机就可以建立了一个可靠的连接，接下来就可以发送数据了，在发送数据之前，可以通过 Window 字段协商一个窗口大小。
	在数据发送过程中，TCP 协议和无连接协议 UDP 也有本质的区别。
	UDP 在发送的时候，是非常无脑的，就是生传，期间没有任何停顿，也没有任何确认，不管你数据是否收到，也不管在发送过程中是否会出现拥塞卡顿的情况。
	但是 TCP 不行，TCP 是在原目双方建立完连接之后，发送方发送段数据之后得停下来，等待接收方的确认消息，以保证接受方的数据到底有没有收到。
	接收方收到了，发送方再发送其他的数据，没收到发送方会给接收方重传。

	滑动 Window 会根据链路带宽的实际情况，来回变动，以适应当前链路。
	根据链路网络的时时质量来调整传输的速率，TCP Slow Start 1 2，4，8，16，越发越快慢慢填充带宽，等带宽被填充完以后，再逐渐减半 window。

字段含义

	Source Prot：		源端口号 标识是那个应用程序产生了这股流量
	Destination Prot： 	目的端口号 标识的是那个应用程序接受这股流量
	Sequence Number：序列号 能保证切片在接受方，收到以后能顺序的将数据重组，从而保证数据的序列性，
	Acknowledge Number：确认号 防止报文丢包，保证发送方传输的数据有没有丢包，确认重传。
						A------B 主机 A 给主机 B 发送数据，序列号依次是1,2,3,主机 B 收到了1，2，3，
						那么主机 B 再给 A 回的时候 ACK 报文中的确认号就是 4，
						当 A 收到确认号为 4 的 ACK 以后，A 就向 B发送 4，5，6了。
						如果 6 丢包了，B 只收到了 4 和 5，B 再给 A回确认报文的时候，确认号就是 6，
						A 会从 6开始往后发，如果 B回的确认号是 5，那 A 就从 5 开始重发。
	Header Length:报头的长度 4bit
	Resv：保留位,以后使用。6bit

	几个标志位各占 1bit 用 0 和 1 标识有效

	URG(URGent)：表示 紧急指针字段 Urgent Pointer 是否有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不是按原来的排队顺序来传送。比如 Ctrl+C。
	ACK(Acknowledge)：确认 仅当 ACK=1 是 ack 确认号 字段才有效。当 ACK=0 时，ack 确认号 无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为1
	PSH(Push)：提示接收端应用程序，将数据立刻从 TCP 的缓冲区读走。
	RST(Reset)：表示 复位 重新建立连接。
				当 RST=1 时，表明 TCP 连接中出现较为严重的差错（如由于主机崩溃），必须释放连接，然后再重新建立运输连接。
				RST 置为 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。

	SYN(SYNchronization)：同步 请求连接建立，用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接报文请求 Request 段。
						  对方同意建立连接，则响应 Reply 的报文段中使用 SYN=1 和 ACK=1。
	FIN(FINis，意思是“完”、“终”):终止 用来释放一个连接。当 FIN=1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。

	window size	：窗口大小，流量控制。最大65535。
	Checksum：校验和 既能校验 4层数据段头，还能校验数据载荷，防冲突防篡改，

	Urgent Pointer：紧急指针 占 2 个 byte 字节。紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)。
					因此紧急指针指出来紧急指针的末尾在报文段中的位置。

	任何应用基于 TCP 封装数据都只能产生单播流量，TCP 是一种点到点协议，基于 TCP 只能使用单播，要用组播请用 UDP。

无连接协议：

	如果，使用无连接协议，来封装应用数据的时候，虽然可以发，但是能不能到，在发送过程中会不会出现问题，就没办法控制了，尽力而为的协议。

	UDP 是一个无连接协议，传输可靠性没有保证，传输数据时没有确认机制。
	UDP 除了原目端口号，就没有别能力了，还有校验和，长度。
	对于 UDP 协议而言，这个协议本身是无连接的协议，对数据包的到达顺序以及是否正确到达不甚关心，所以一般 UDP 应用对分片没有特殊要求。
	对于 TCP 协议而言就不一样了，这个协议是面向连接的协议，对于 TCP 协议而言它非常在意数据包的到达顺序以及是否传输中有错误发生。

既然 UDP 这么不可靠为什么还要用 UDP？
	
	在 TCP/IP 协议栈中基于 TCP 和 UDP 封装的应用可以说是各占 50%，甚至基于 UDP 的应用更多，这要从安全性说起。
	TCP 能提供可靠的传输的能力，但是请千万不要把可靠和安全之间划等号。
	可靠是可靠，安全是安全，TCP 能够提供可靠传输能力，但是，它并不安全，往往基于 TCP 的应用在早期更容易被攻击。

	有一种专门的非常有名的攻击，就是针对基于 TCP 的应用所开发的，TCP SYN Flooding Attack TCP 同步泛洪攻击，是一种经典的 Dos 拒绝服务攻击，
	通过某种手段消耗服务主机的资源，比如 CPU，缓存，内存，接口，带宽，这些资源消耗殆尽，这台服务器就无法给客户正常服务了。

TCP SYN Flooding Attack TCP 同步泛洪攻击是怎么回事呢？

	任何基于TCP的应用，在产生流量之前，都先要完成三次握手，

	1.Client 发起一个 SYN 到 Server 服务器的应用 Service；
	2.Server 收到以后给 Client 回一个 SYN+ACK；
	3.Client 收到以后再给 Server 的应用 Service 回一个 ACK；

	完成以上三步，建立完整连接。
	如果只完成了1步和2步的报文交互，没有完成三次握手被称之为不完整连接。
	TCP SYN Flooding Attack就是基于三次握手进行攻击的。
	黑客不停的变换 IP 地址，给服务器发送 SYN 同步报文，Server 服务器每收到一个连接就会记录一个 Socket 连接，并且给攻击者回一个 SYN+ACK，
	但是，攻击者再收到这个 SYN + ACK 之后，不会给服务器回复最后一个 ACK；
	黑客也有可能根本收不到这个 SYN + ACK，因为攻击者，给服务器发送 SYN 的时候，可以给你修改 3 层报头原 IP 地址，
	可以各种修改，服务器按照修改后的 IP 地址给回 SYN + ACK 黑客根本收不到，
	这个时候服务会认为有很多台主机尝试给我建立连接，但是，他们建立完半开连接之后都不给 Server 服务器回应 ACK 了，
	基于 TCP 的应用一般都比较弱，他们不会要求服务器半开连接维持多长时间就要被关掉，
	只要半开连接存在，默认就会永久存在，内存总会被好紧，这个 DOS 攻击就成功了。

怎么防这种攻击呢？

	现在有些应用比较机智，会给这个半开会话限制一个时间，到时间没有完成就清除连接，
	在设计基于 TCP 应用的时候，这个应用要协助 TCP 设置一个计时器，计时器限制半开会话最多维持多长时间，
	并且服务器一般都在一个 DMZ 非军事化区域，这个非军事化区域往往连接一个防火墙，
	这个防火墙会记录会话流量，防火墙上也可以设置一些预值，比如说针对一台服务器，我的最多半开连接，只能有 2000个。
	如果超过 2000个就会把之前的半开连接给你断开，如果超过太多了就会清一色的所有半开连接都给你干掉。
	防不胜防。

	UDP 比较难以实现，就算有了也可以通过防火墙干掉，火墙开起指纹识别功能，能识别攻击流量的特征。
	一般的攻击流量都是用 Kali Linux 产生的，基于 Linux 的攻击包都很有共同性，他们内部都有一些代码参数都是匹配的。
	这个时候通过指纹识别流量流量特征，干掉攻击。

	Internet 中有三种流量单播，组播和广播，TCP 是一个点到点协议，只支持单播。
	当你想要用组播和广播发送流量，只能使用 UDP，想要发送 Voip 视频等这些基于网络发送的多媒体流量，基本都是以组播的形式发的。
	UDP 报头小，数据占比大，效率高，使用 TCP 最大的好处就是传失败了能重传，
	有很多应用尤其是媒体应用，通过网络打电话，我们通过网络传视频，肯定是不能重传，会影响连续的流。

	qq 的消息就是基于 UDP 的，应用本身要提供可靠传输。

	RTP 实时传输协议，给流量传输提供序列性，RTP 报头中包含一个序列号字段，通过序列号判断传输是否有乱序。
	Enternet2|ipv4|udp|RTP|VolP|FCS

三次握手(TCP的建立可靠连接)，以及状态转换。有限状态机。

					CLIENT							    SERVER
		CLOSED		|---|								|---|   CLOSED
					|	|								|	|
		    		|   |								|   |	LISTEN 被动打开 等待 人进来
		主动打开连接  |	  |								  |	  |	listen()
		connect()	|	|	SYN=1,sqe=INS_A				|	|
		SYN_SEND	|	|------------------------------>|	|	SYN_RECEIVED
		        	|	|								|	|
					|	|								|	|
					|	|   ACK=1,ack=INS_A+1;			|	|
		 ,   , ,	|	|   SYN=1,sqe=INS_B	            |	|
	ES TAB LISHED	|	|<------------------------------|	|
					|	|								|	|
					|	|								|	|
					|	|								|	|
					|	|	ACK=1,ack=INS_B+1			|	|
					|	|------------------------------>|	|	ESTABLISHED
					|	|								|	|   已连接
					|	|		        			    |	|
					|---|<-----------交换数据----------->｜---|


	客户端发报文：SYN=1，seq=x；

	服务器回应报文：SYN=1，ACK=1，seq=y，ack=x+1；

	客户端回应报文：ACK=1，seq=x+1，ack=y+1;

	1.TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态；
	
	2.TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位 SYN=1，同时选择一个初始序列号 seq=x ，
	  此时，TCP 客户端进程进入了 SYN-SENT（同步已发送）状态。
	  TCP 规定，SYN 报文段(SYN=1的报文段)不能携带数据，但需要消耗掉一个序号 seq。
	  
	3.TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。
	  确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，
	  此时，TCP 服务器进程进入了 SYN-RCVD (同步收到)状态。这个报文也不能携带数据，但是同样要消耗一个序号 seq。
	  
	4.TCP 客户进程收到确认后，还要向服务器给出确认。
	  确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，
	  此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。
	  TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。
	  
	5.当服务器收到客户端的确认后也进入 ESTABLISHED（已建立连接）状态，此后双方就可以开始通信了。

为什么建立 TCP 连接，客户端最后还要发送一次确认呢？

	主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

	如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，
	由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。
	此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，
	但是，两次握手的机制将会让客户端和服务器 *再次建立连接*，这将导致不必要的错误和资源的浪费。

	如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。
	由于服务器收不到确认，就知道客户端并没有请求连接。

四次挥手(TCP 连接的释放)

					A									B
		ESTABLISHED	|---|								|---|   ESTABLISHED
		        	|	|								|	|
		close()     |	|	FIN=1,sqe=INS_A				|	|
		FIN_WAIT1	|	|------------------------------>|	|
		主动关闭方	|	|								|	|
					|	|								|	|	
					|	|								|	|
		单双工		|	| 	ACK=1,ack=INS_A+1			|	|   被动关闭方
		FIN_WAIT2	|	|<------------------------------|	|	CLOSE_WAIT	
					|	|								|	|
					|	|								|	|	
					|	|								|	|
					|	|	FIN=1,sqe=INS_B				|	|
		TIME_WAIT	|	|<------------------------------|	|	LAST_ACK
		        	|	|								|	|
        2MSL=120秒	|	|	ACK=1,ack=INS_B+1			|	|
		CLOSED		|	|------------------------------>|	|	CLOSED
					|	|								|	|
					|---|								|---|
		
	三 waite 一个 close									一 waite 一 last 一 close

	客户端发送报文：FIN=1，seq=a；

	服务器响应报文：ACK=1，seq=b，ack=a+1；

	服务器发送报文：FIN=1，ACK=1，seq=c，ack=a+1；

	客户端响应报文：ACK=1，seq=a+1，ack=c+1

	1.客户端进程发出连接释放报文，并且停止发送数据。
	  释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），
	  此时，客户端进入 FIN-WAIT-1（终止等待1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。
	  
	2.服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，
	  此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。
	  TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，
	  这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
	  这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
	  
	3.客户端收到服务器的确认请求后，
	  此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
	  
	4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，
	  由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，
	  此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。
	  
	5.客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，
	  此时，客户端就进入了 TIME-WAIT（时间等待）状态。
	  注意此时 TCP 连接还没有释放，必须经过 2MSL（最大段生存时间）的时间后,为了防止最后一次客户端 ACK，服务端未收到的情况，
	  当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。
	  
	6.服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。
	  可以看到，服务器结束 TCP 连接的时间要比客户端早一些。

为什么客户端最后还要等待 2MSL？

	MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。

	第一，保证 客户端 发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在 服务器 的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，
	应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。

	第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。 
	客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以 使本连接 持续的时间内所产生的所有报文段都从网络中消失。
	这样，如果我们再次马上创建新连接中，不会出现 旧连接中 的请求报文。

为什么建立连接是三次握手，关闭连接确是四次挥手呢？

	建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。
	而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，
	所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，
	因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。

如果已经建立了连接，但是客户端突然出现故障了怎么办？

	TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
	服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，
	若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。
	若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

TCP 长连接
	TCP keepalive 机制
	TCP 长连接,短连接，是对于使用 应用层协议 开发的 应用程序 在使用 TCP 协议时的方式而言的。
	在不考虑应用层的作用时，单纯从传输控制层建立的 TCP 连接而言，它是一个所谓的“一直连接”。
	如果服务端不做超时处理的话，只要客户端连接上了服务器，这个连接资源在两端是一直存在的。默认情况下没有心跳检测。
	因为，当客户端挂掉了，服务器不会马上释放连接，直到 2小时后 的探测故障。
	
	不同的应用程序使用不同的应用层协议，不同的应用层协议，在使用传输层 TCP 协议方式也是不同的。
	例如 应用层协议 HTTP/1.0 ，Client 每次向 Server Request数据时，都需要建立 TCP 连接，Server 向 Client Response 数据完毕后，立马释放 TCP 连接，以腾出资源。
	因此。HTTP/1.0 使用的是 TCP 连接是短连接。
	HTTP/1.0 一次 Request，一次 Reply 必须成对，共用一个 TCP 连接。
	因为 HTTP 协议是无状态的，如果 Client 连续发送多次 Request，服务端多次 Reply。Client 就不知道那个 Reply 到底是对应这那个 Request。

	如果设置了 TCP keepalive 就告诉服务器，你别给我关这个连接，我下次请还要使用这个连接，这样就不用每次发起强求都建立连接了。

MTU
	
	MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，
	EthernetII 帧的结构 DMAC + SMAC + Type + Data + CRC 由于以太网传输电气方面的限制，
	每个以太网帧都有最小的大小 64 Bytes，最大不能超过 1518 Bytes，
	对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。

	由于以太网 EthernetII 最大的数据帧是 1518 Bytes 这样，
	刨去以太网帧的帧头[ DMAC(目的 MAC) 地址 48 bit = 6 Bytes + SMAC(源 MAC 地址)48 bit = 6 Bytes + Type 域 2 Bytes）14 Bytes 和帧尾 CRC 校验部分 4 Bytes，
	那么剩下承载上层协议的地方，也就是 Data 域最大就只能有 1500 Bytes，这个值我们就把它称之为 MTU。

	PPPoE 所谓 PPPoE 就是在以太网上面跑 PPP 协议，有人奇怪了，PPP 协议和 Ethernet 不都是链路层协议吗？
	怎么一个链路层跑到另外一个链路层上面去了，难道升级成网络层协议了不成。
	其实这是个误区：就是某层协议只能承载更上一层协议。

为什么会产生这种奇怪的需求呢？

	这是因为随着宽带接入（这种宽带接入一般为 Cable Modem 或者 xDSL 或者以太网的接入），
	因为以太网缺乏认证计费机制而传统运营商是通过 PPP 协议来对拨号等接入服务进行认证计费的.

	PPPoE 带来了好处，也带来了一些坏处，
	比如：二次封装耗费资源，降低了传输效能等等，这些坏处俺也不多说了，
	最大的坏处就是 PPPoE 导致 MTU 变小了以太网的 MTU 是 1500，再减去 PPP 的包头包尾的开销（8 Bytes），就变成 1492。

	UDP 包的大小就应该是 1492 - IP 头(20) - UDP 头(8) = 1464(Bytes)
	TCP 包的大小就应该是 1492 - IP 头(20) - TCP 头(20) = 1452(Bytes)

	目前大多数的路由设备的 MTU 都为1500
	我对上面的理解是：如果我们定义的 TCP 和 UDP 包小于 1452，1464，那么我们的包在 IP 层就不用分包了，这样传输过程中就避免了在 IP 层组包发生的错误。
	如果使用 UDP 协议，如果 IP 层组包发生错误，那么包就会被丢弃，UDP 不保证可靠传输。
	但是 TCP 发生组包错误时，该包会被重传，保证可靠传输。
	所以，我们在用 Socket 编程时，包的大小设定不一定非要小于 1400，UDP 协议要求包小于64K，TCP 没有限定。

总结：

	我们设定包的大小对于 UDP 和 TCP 协议是不同的，关键是看系统性能和网络性能，网络是状态很好的局域网，那么 UDP 包分大点，提高系统的性能。
	不好，就分小于1464，这样可以减低丢包率。
	对于 TCP 来说，这个就要靠经验了，
	因为，TCP 丢包可以自动重传，分大了，系统性能提高了，分包和错误重组可能会耗费时间，使传送时间延长，分小了，系统性能又降低了。
